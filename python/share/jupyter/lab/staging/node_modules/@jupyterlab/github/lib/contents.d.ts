import { ISignal } from '@lumino/signaling';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { ObservableValue } from '@jupyterlab/observables';
import { Contents, ServerConnection } from '@jupyterlab/services';
export declare const DEFAULT_GITHUB_API_URL = "https://api.github.com";
export declare const DEFAULT_GITHUB_BASE_URL = "https://github.com";
/**
 * A Contents.IDrive implementation that serves as a read-only
 * view onto GitHub repositories.
 */
export declare class GitHubDrive implements Contents.IDrive {
    /**
     * Construct a new drive object.
     *
     * @param options - The options used to initialize the object.
     */
    constructor(registry: DocumentRegistry);
    /**
     * The name of the drive.
     */
    get name(): 'GitHub';
    /**
     * State for whether the user is valid.
     */
    get validUser(): boolean;
    /**
     * Settings for the notebook server.
     */
    get serverSettings(): ServerConnection.ISettings;
    /**
     * State for whether the drive is being rate limited by GitHub.
     */
    readonly rateLimitedState: ObservableValue;
    /**
     * A signal emitted when a file operation takes place.
     */
    get fileChanged(): ISignal<this, Contents.IChangedArgs>;
    /**
     * Test whether the manager has been disposed.
     */
    get isDisposed(): boolean;
    /**
     * Dispose of the resources held by the manager.
     */
    dispose(): void;
    /**
     * The GitHub base URL
     */
    get baseUrl(): string;
    /**
     * The GitHub base URL is set by the settingsRegistry change hook
     */
    set baseUrl(url: string);
    /**
     * The GitHub access token
     */
    get accessToken(): string | null | undefined;
    /**
     * The GitHub access token is set by the settingsRegistry change hook
     */
    set accessToken(token: string | null | undefined);
    /**
     * Get a file or directory.
     *
     * @param path: The path to the file.
     *
     * @param options: The options used to fetch the file.
     *
     * @returns A promise which resolves with the file content.
     */
    get(path: string, options?: Contents.IFetchOptions): Promise<Contents.IModel>;
    /**
     * Get an encoded download url given a file path.
     *
     * @param path - An absolute POSIX file path on the server.
     *
     * #### Notes
     * It is expected that the path contains no relative paths,
     * use [[ContentsManager.getAbsolutePath]] to get an absolute
     * path if necessary.
     */
    getDownloadUrl(path: string): Promise<string>;
    /**
     * Create a new untitled file or directory in the specified directory path.
     *
     * @param options: The options used to create the file.
     *
     * @returns A promise which resolves with the created file content when the
     *    file is created.
     */
    newUntitled(options?: Contents.ICreateOptions): Promise<Contents.IModel>;
    /**
     * Delete a file.
     *
     * @param path - The path to the file.
     *
     * @returns A promise which resolves when the file is deleted.
     */
    delete(path: string): Promise<void>;
    /**
     * Rename a file or directory.
     *
     * @param path - The original file path.
     *
     * @param newPath - The new file path.
     *
     * @returns A promise which resolves with the new file contents model when
     *   the file is renamed.
     */
    rename(path: string, newPath: string): Promise<Contents.IModel>;
    /**
     * Save a file.
     *
     * @param path - The desired file path.
     *
     * @param options - Optional overrides to the model.
     *
     * @returns A promise which resolves with the file content model when the
     *   file is saved.
     */
    save(path: string, options: Partial<Contents.IModel>): Promise<Contents.IModel>;
    /**
     * Copy a file into a given directory.
     *
     * @param path - The original file path.
     *
     * @param toDir - The destination directory path.
     *
     * @returns A promise which resolves with the new contents model when the
     *  file is copied.
     */
    copy(fromFile: string, toDir: string): Promise<Contents.IModel>;
    /**
     * Create a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with the new checkpoint model when the
     *   checkpoint is created.
     */
    createCheckpoint(path: string): Promise<Contents.ICheckpointModel>;
    /**
     * List available checkpoints for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with a list of checkpoint models for
     *    the file.
     */
    listCheckpoints(path: string): Promise<Contents.ICheckpointModel[]>;
    /**
     * Restore a file to a known checkpoint state.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to restore.
     *
     * @returns A promise which resolves when the checkpoint is restored.
     */
    restoreCheckpoint(path: string, checkpointID: string): Promise<void>;
    /**
     * Delete a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to delete.
     *
     * @returns A promise which resolves when the checkpoint is deleted.
     */
    deleteCheckpoint(path: string, checkpointID: string): Promise<void>;
    /**
     * If a file is too large (> 1Mb), we need to access it over the
     * GitHub Git Data API.
     */
    private _getBlob;
    /**
     * List the repositories for the currently active user.
     */
    private _listRepos;
    /**
     * Determine whether to make the call via the
     * notebook server proxy or not.
     */
    private _apiRequest;
    private _baseUrl;
    private _accessToken;
    private _validUser;
    private _serverSettings;
    private _useProxy;
    private _fileTypeForPath;
    private _isDisposed;
    private _fileChanged;
}
/**
 * Specification for a file in a repository.
 */
export interface IGitHubResource {
    /**
     * The user or organization for the resource.
     */
    readonly user: string;
    /**
     * The repository in the organization/user.
     */
    readonly repository: string;
    /**
     * The path in the repository to the resource.
     */
    readonly path: string;
}
/**
 * Parse a path into a IGitHubResource.
 */
export declare function parsePath(path: string): IGitHubResource;
