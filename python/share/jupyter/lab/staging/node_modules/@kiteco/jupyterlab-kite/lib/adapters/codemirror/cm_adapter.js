import { until_ready } from '../../utils';
export class CodeMirrorAdapter {
    constructor(editor, virtual_document, jupyterlab_components, features = new Array()) {
        this.editor = editor;
        this.virtual_document = virtual_document;
        this.jupyterlab_components = jupyterlab_components;
        this.isDisposed = false;
        this.saveChange = (doc, change) => {
            this.last_change = change;
        };
        this.editor.on('change', this.saveChange);
        this.features = new Map();
        for (let feature of features) {
            feature.register();
            if (!feature.is_registered) {
                this.editor.console.warn('The feature ', feature, 'was not registered properly');
            }
            this.features.set(feature.name, feature);
        }
    }
    async updateAfterChange() {
        this.jupyterlab_components.remove_tooltip();
        try {
            await until_ready(() => this.last_change != null, 30, 22);
        }
        catch (err) {
            console.log('No change obtained from CodeMirror editor within the expected time of 0.66s');
            return;
        }
        let change = this.last_change;
        let root_position;
        try {
            root_position = this.editor.getDoc().getCursor('end');
        }
        catch (err) {
            console.log('LSP: Root positon not found');
            return;
        }
        try {
            let document = this.editor.document_at_root_position(root_position);
            if (this.virtual_document !== document) {
                return true;
            }
            if (!change || !change.text.length || !change.text[0].length) {
                // deletion - ignore
                // TODO(naman) this should probably be handled by the individual features for more flexibility
                return true;
            }
            for (let feature of this.features.values()) {
                feature.afterChange(change, root_position);
            }
            return true;
        }
        catch (e) {
            this.editor.console.log('updateAfterChange failure');
            this.editor.console.error(e);
        }
        this.invalidateLastChange();
    }
    invalidateLastChange() {
        this.last_change = null;
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        for (let feature of this.features.values()) {
            feature.remove();
        }
        this.features.clear();
        this.editor.off('change', this.saveChange);
        // just to be sure
        this.editor = null;
        // actually disposed
        this.isDisposed = true;
    }
}
//# sourceMappingURL=cm_adapter.js.map