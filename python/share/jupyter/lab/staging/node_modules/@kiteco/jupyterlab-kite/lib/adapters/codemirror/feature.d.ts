import { VirtualDocument } from '../../virtual/document';
import { CodeMirrorHandler, VirtualEditor } from '../../virtual/editor';
import { LSPConnection } from '../../connection';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../../positioning';
import { IJupyterLabComponentsManager, StatusMessage } from '../jupyterlab/jl_adapter';
import * as lsProtocol from 'vscode-languageserver-protocol';
import * as CodeMirror from 'codemirror';
import { ICommandContext } from '../../command_manager';
export declare enum CommandEntryPoint {
    CellContextMenu = 0,
    FileEditorContextMenu = 1
}
export interface IFeatureCommand {
    /**
     * The command id; it will be prepended with 'lsp' prefix.
     * To support multiple attachment points, multiple actual commands will be created,
     * identified by an attachment-point-specific suffix.
     */
    id: string;
    execute: (context: ICommandContext) => void;
    is_enabled: (context: ICommandContext) => boolean;
    label: string;
    /**
     * Default infinity (unassigned) if absolute, otherwise 0 (for relative ranks)
     */
    rank?: number;
    /**
     * Does the rank represent relative position in the LSP commands group? (default: true)
     */
    is_rank_relative?: boolean;
    /**
     * By default the command will be attached to the cell and file editor context menus.
     */
    attach_to?: Set<CommandEntryPoint>;
}
export interface ILSPFeature {
    /**
     * The user-readable name of the feature
     */
    name: string;
    is_registered: boolean;
    virtual_editor: VirtualEditor;
    virtual_document: VirtualDocument;
    connection: LSPConnection;
    jupyterlab_components: IJupyterLabComponentsManager;
    /**
     * Connect event handlers to the editor, virtual document and connection(s)
     */
    register(): void;
    /**
     * Will allow the user to disable specific functions
     */
    isEnabled(): boolean;
    /**
     * Remove event handlers on destruction
     */
    remove(): void;
    afterChange(change: CodeMirror.EditorChange, // TODO: provide an editor-diagnostic abstraction layer for EditorChange
    root_position: IRootPosition): void;
}
export interface IEditorRange {
    start: IEditorPosition;
    end: IEditorPosition;
    editor: CodeMirror.Editor;
}
export interface IEditOutcome {
    appliedChanges: number | null;
    modifiedCells: number;
    wasGranular: boolean;
    errors: string[];
}
/**
 * One feature of each type exists per VirtualDocument
 * (the initialization is performed by the adapter).
 */
export declare abstract class CodeMirrorLSPFeature implements ILSPFeature {
    virtual_editor: VirtualEditor;
    virtual_document: VirtualDocument;
    connection: LSPConnection;
    jupyterlab_components: IJupyterLabComponentsManager;
    status_message: StatusMessage;
    is_registered: boolean;
    protected readonly editor_handlers: Map<string, CodeMirrorHandler>;
    protected readonly connection_handlers: Map<string, any>;
    protected readonly wrapper_handlers: Map<keyof HTMLElementEventMap, any>;
    protected wrapper: HTMLElement;
    constructor(virtual_editor: VirtualEditor, virtual_document: VirtualDocument, connection: LSPConnection, jupyterlab_components: IJupyterLabComponentsManager, status_message: StatusMessage);
    abstract get name(): string;
    register(): void;
    isEnabled(): boolean;
    /** Return JupyterLab commands to be registered;
     * intended for single-use in index.ts (during extension registration)
     */
    static readonly commands: IFeatureCommand[];
    private commands;
    remove(): void;
    afterChange(change: CodeMirror.EditorChange, root_position: IRootPosition): void;
    protected range_to_editor_range(range: lsProtocol.Range, cm_editor?: CodeMirror.Editor): IEditorRange;
    protected position_from_mouse(event: MouseEvent): IRootPosition;
    protected transform_virtual_position_to_root_position(start: IVirtualPosition): IRootPosition;
    protected get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    protected get_language_at(position: IEditorPosition, editor: CodeMirror.Editor): any;
    protected extract_last_character(change: CodeMirror.EditorChange): string;
    protected highlight_range(range: IEditorRange, class_name: string): CodeMirror.TextMarker;
    /**
     * Does the edit cover the entire document?
     */
    protected is_whole_document_edit(edit: lsProtocol.TextEdit): boolean;
    protected apply_edit(workspaceEdit: lsProtocol.WorkspaceEdit): Promise<IEditOutcome>;
    protected replace_fragment(newText: string, editor: CodeMirror.Editor, fragment_start: CodeMirror.Position, fragment_end: CodeMirror.Position, start: CodeMirror.Position, end: CodeMirror.Position, is_whole_document_edit?: boolean): number;
    protected apply_single_edit(edit: lsProtocol.TextEdit): number;
}
export declare type ILSPFeatureConstructor = {
    new (...args: any[]): CodeMirrorLSPFeature;
    commands: Array<IFeatureCommand>;
};
