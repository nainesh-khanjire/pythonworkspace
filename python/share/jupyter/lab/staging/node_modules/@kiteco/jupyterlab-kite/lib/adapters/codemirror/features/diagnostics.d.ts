import * as lsProtocol from 'vscode-languageserver-protocol';
import { CodeMirrorLSPFeature, IFeatureCommand } from '../feature';
import { MainAreaWidget } from '@jupyterlab/apputils';
import { DiagnosticsDatabase, DiagnosticsListing } from './diagnostics_listing';
import { VirtualEditor } from '../../../virtual/editor';
declare class DiagnosticsPanel {
    private _content;
    private _widget;
    is_registered: boolean;
    get widget(): MainAreaWidget<DiagnosticsListing>;
    get content(): DiagnosticsListing;
    protected init_widget(): MainAreaWidget<DiagnosticsListing>;
    update(): void;
}
export declare const diagnostics_panel: DiagnosticsPanel;
export declare const diagnostics_databases: WeakMap<VirtualEditor, DiagnosticsDatabase>;
export declare class Diagnostics extends CodeMirrorLSPFeature {
    name: string;
    static commands: Array<IFeatureCommand>;
    register(): void;
    private unique_editor_ids;
    private marked_diagnostics;
    /**
     * Allows access to the most recent diagnostics in context of the editor.
     *
     * One can use VirtualEditorForNotebook.find_cell_by_editor() to find
     * the corresponding cell in notebook.
     * Can be used to implement a Panel showing diagnostics list.
     *
     * Maps virtual_document.uri to IEditorDiagnostic[].
     */
    diagnostics_db: DiagnosticsDatabase;
    switchDiagnosticsPanelSource: () => void;
    protected collapse_overlapping_diagnostics(diagnostics: lsProtocol.Diagnostic[]): Map<lsProtocol.Range, lsProtocol.Diagnostic[]>;
    handleDiagnostic: (response: lsProtocol.PublishDiagnosticsParams) => void;
    protected remove_unused_diagnostic_markers(to_retain: Set<string>): void;
    remove(): void;
}
export declare function message_without_code(diagnostic: lsProtocol.Diagnostic): string;
export {};
