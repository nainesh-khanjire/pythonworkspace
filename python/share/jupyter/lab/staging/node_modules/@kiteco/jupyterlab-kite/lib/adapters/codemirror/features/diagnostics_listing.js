import React from 'react';
import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';
import '../../../../style/diagnostics_listing.css';
import { diagnosticSeverityNames } from '../../../lsp';
import { message_without_code } from './diagnostics';
export const DIAGNOSTICS_LISTING_CLASS = 'lsp-diagnostics-listing';
export class DiagnosticsDatabase extends Map {
    get all() {
        return [].concat.apply([], this.values());
    }
}
function focus_on(node) {
    if (!node) {
        return;
    }
    node.scrollIntoView();
    node.focus();
}
function DocumentLocator(props) {
    let { document, editor } = props;
    let ancestry = document.ancestry;
    let target_cell = null;
    let breadcrumbs = ancestry.map(document => {
        if (!document.parent) {
            let path = document.path;
            if (!editor.has_lsp_supported_file &&
                path.endsWith(document.file_extension)) {
                path = path.slice(0, -document.file_extension.length - 1);
            }
            return React.createElement("span", { key: document.uri }, path);
        }
        if (!document.virtual_lines.size) {
            return React.createElement("span", { key: document.uri }, "Empty document");
        }
        try {
            if (editor.has_cells) {
                let first_line = document.virtual_lines.get(0);
                let last_line = document.virtual_lines.get(document.last_virtual_line - 1);
                let notebook_editor = editor;
                let { cell_id: first_cell, cell } = notebook_editor.find_cell_by_editor(first_line.editor);
                let { cell_id: last_cell } = notebook_editor.find_cell_by_editor(last_line.editor);
                target_cell = cell;
                let cell_locator = first_cell === last_cell
                    ? `cell ${first_cell + 1}`
                    : `cells: ${first_cell + 1}-${last_cell + 1}`;
                return (React.createElement("span", { key: document.uri },
                    document.language,
                    " (",
                    cell_locator,
                    ")"));
            }
        }
        catch (e) {
            console.warn('LSP: could not display document cell location', e);
        }
        return React.createElement("span", { key: document.uri }, document.language);
    });
    return (React.createElement("div", { className: 'lsp-document-locator', onClick: () => focus_on(target_cell ? target_cell.node : null) }, breadcrumbs));
}
class Column {
    constructor(options) {
        this.options = options;
        this.is_visible = true;
    }
    render_cell(data, context) {
        return this.options.render_cell(data, context);
    }
    sort(a, b) {
        return this.options.sort(a, b);
    }
    get name() {
        return this.options.name;
    }
    is_available(context) {
        if (this.options.is_available != null) {
            return this.options.is_available(context);
        }
        return true;
    }
    render_header(listing) {
        return React.createElement(SortableTH, { name: this.name, listing: listing, key: this.name });
    }
}
function SortableTH(props) {
    const is_sort_key = props.name === props.listing.sort_key;
    return (React.createElement("th", { key: props.name, onClick: () => props.listing.sort(props.name), className: is_sort_key
            ? 'lsp-sorted ' +
                (props.listing.sort_direction === 1 ? 'lsp-descending' : '')
            : '' },
        props.name,
        is_sort_key ? React.createElement("span", { className: 'lsp-caret' }) : null));
}
export class DiagnosticsListing extends VDomRenderer {
    constructor() {
        super(...arguments);
        this.sort_key = 'Severity';
        this.sort_direction = 1;
        this.columns = [
            new Column({
                name: 'Virtual Document',
                render_cell: (row, context) => (React.createElement("td", { key: 0 },
                    React.createElement(DocumentLocator, { document: row.document, editor: context.editor }))),
                sort: (a, b) => a.document.id_path.localeCompare(b.document.id_path),
                is_available: context => context.db.size > 1
            }),
            new Column({
                name: 'Message',
                render_cell: row => {
                    let message = message_without_code(row.data.diagnostic);
                    return React.createElement("td", { key: 1 }, message);
                },
                sort: (a, b) => a.data.diagnostic.message.localeCompare(b.data.diagnostic.message)
            }),
            new Column({
                name: 'Code',
                render_cell: row => React.createElement("td", { key: 2 }, row.data.diagnostic.code),
                sort: (a, b) => (a.data.diagnostic.code + '').localeCompare(b.data.diagnostic.source + '')
            }),
            new Column({
                name: 'Severity',
                // TODO: use default diagnostic severity
                render_cell: row => (React.createElement("td", { key: 3 }, diagnosticSeverityNames[row.data.diagnostic.severity || 1])),
                sort: (a, b) => a.data.diagnostic.severity > b.data.diagnostic.severity ? 1 : -1
            }),
            new Column({
                name: 'Source',
                render_cell: row => React.createElement("td", { key: 4 }, row.data.diagnostic.source),
                sort: (a, b) => a.data.diagnostic.source.localeCompare(b.data.diagnostic.source)
            }),
            new Column({
                name: 'Cell',
                render_cell: row => React.createElement("td", { key: 5 }, row.cell_number),
                sort: (a, b) => (a.cell_number > b.cell_number ? 1 : -1),
                is_available: context => context.editor.has_cells
            }),
            new Column({
                name: 'Line',
                render_cell: row => React.createElement("td", { key: 6 }, row.data.range.start.line),
                sort: (a, b) => a.data.range.start.line > b.data.range.start.line ? 1 : -1
            }),
            new Column({
                name: 'Ch',
                render_cell: row => React.createElement("td", { key: 7 }, row.data.range.start.line),
                sort: (a, b) => (a.data.range.start.ch > b.data.range.start.ch ? 1 : -1)
            })
        ];
    }
    sort(key) {
        if (key === this.sort_key) {
            this.sort_direction = this.sort_direction * -1;
        }
        else {
            this.sort_key = key;
            this.sort_direction = 1;
        }
        this.update();
    }
    render() {
        let diagnostics_db = this.model.diagnostics;
        const editor = this.model.virtual_editor;
        if (!diagnostics_db || editor == null) {
            return React.createElement("div", null, "No issues detected, great job!");
        }
        let by_document = Array.from(diagnostics_db).map(([virtual_document, diagnostics]) => {
            if (virtual_document.isDisposed) {
                return [];
            }
            return diagnostics.map((diagnostic_data, i) => {
                let cell_number = null;
                if (editor.has_cells) {
                    let notebook_editor = editor;
                    let { cell_id } = notebook_editor.find_cell_by_editor(diagnostic_data.editor);
                    cell_number = cell_id + 1;
                }
                return {
                    data: diagnostic_data,
                    key: virtual_document.uri + ',' + i,
                    document: virtual_document,
                    cell_number: cell_number,
                    editor: editor
                };
            });
        });
        let flattened = [].concat.apply([], by_document);
        let sorted_column = this.columns.filter(column => column.name === this.sort_key)[0];
        let sorter = sorted_column.sort.bind(sorted_column);
        let sorted = flattened.sort((a, b) => sorter(a, b) * this.sort_direction);
        let context = {
            db: diagnostics_db,
            editor: editor
        };
        let columns_to_display = this.columns.filter(column => column.is_available(context) && column.is_visible);
        let elements = sorted.map(row => {
            let cm_editor = row.data.editor;
            let cells = columns_to_display.map(column => column.render_cell(row, context));
            return (React.createElement("tr", { key: row.key, onClick: () => {
                    focus_on(cm_editor.getWrapperElement());
                    cm_editor.getDoc().setCursor(row.data.range.start);
                    cm_editor.focus();
                } }, cells));
        });
        let columns_headers = columns_to_display.map(column => column.render_header(this));
        return (React.createElement("table", { className: DIAGNOSTICS_LISTING_CLASS },
            React.createElement("thead", null,
                React.createElement("tr", null, columns_headers)),
            React.createElement("tbody", null, elements)));
    }
}
(function (DiagnosticsListing) {
    /**
     * A VDomModel for the LSP of current file editor/notebook.
     */
    class Model extends VDomModel {
        constructor() {
            super();
        }
    }
    DiagnosticsListing.Model = Model;
})(DiagnosticsListing || (DiagnosticsListing = {}));
//# sourceMappingURL=diagnostics_listing.js.map