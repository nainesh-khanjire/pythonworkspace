import { DataConnector } from '@jupyterlab/statedb';
import { CompletionHandler } from '@jupyterlab/completer';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { Session } from '@jupyterlab/services';
import { CompletionTriggerKind } from '../../../lsp';
import { VirtualDocument } from '../../../virtual/document';
import { VirtualEditor } from '../../../virtual/editor';
import { IRootPosition, IVirtualPosition } from '../../../positioning';
import { LSPConnection } from '../../../connection';
export declare class KiteConnector extends DataConnector<CompletionHandler.ICompletionItemsReply, void, CompletionHandler.IRequest> {
    isDisposed: boolean;
    private _editor;
    private _kernel_connector;
    private _connections;
    protected options: KiteConnector.IOptions;
    private fetchAbort;
    virtual_editor: VirtualEditor;
    responseType: "ICompletionItemsReply";
    private _trigger_kind;
    private suppress_auto_invoke_in;
    private icon;
    /**
     * Create a new Kite connector for completion requests.
     *
     * @param options - The instantiation options for the Kite connector.
     */
    constructor(options: KiteConnector.IOptions);
    dispose(): void;
    abort(): void;
    /**
     * Fetch completion requests.
     *
     * @param request - The completion request text and details.
     */
    fetch(request?: CompletionHandler.IRequest): Promise<CompletionHandler.ICompletionItemsReply | undefined>;
    fetch_kite(token: CodeEditor.IToken, typed_character: string, start: IVirtualPosition, end: IVirtualPosition, cursor: IVirtualPosition, document: VirtualDocument, position_in_token: number): Promise<CompletionHandler.ICompletionItemsReply>;
    private merge_replies;
    /**
     * Converts an IReply into an ICompletionItemsReply.
     */
    private transform;
    transform_from_editor_to_root(position: CodeEditor.IPosition): IRootPosition;
    get trigger_kind(): CompletionTriggerKind;
    set trigger_kind(kind: CompletionTriggerKind);
    with_trigger_kind(kind: CompletionTriggerKind, fn: Function): any;
}
/**
 * A namespace for Kite connector statics.
 */
export declare namespace KiteConnector {
    /**
     * Interface that adds a noFilter flag to an ICompletionItem
     */
    interface IKiteCompletionItem extends CompletionHandler.ICompletionItem {
        noFilter?: boolean;
    }
    type IKiteCompletionItems = ReadonlyArray<IKiteCompletionItem>;
    /**
     * The instantiation options for cell completion handlers.
     */
    interface IOptions {
        /**
         * The editor used by the LSP connector.
         */
        editor: CodeEditor.IEditor;
        virtual_editor: VirtualEditor;
        /**
         * The connections to be used by the LSP connector.
         */
        connections: Map<VirtualDocument.id_path, LSPConnection>;
        session?: Session.ISessionConnection;
    }
    const EmptyICompletionItemsReply: {
        start: number;
        end: number;
        items: CompletionHandler.ICompletionItems;
    };
    const EmptyIReply: {
        start: number;
        end: number;
        matches: readonly string[];
        metadata: {};
    };
}
