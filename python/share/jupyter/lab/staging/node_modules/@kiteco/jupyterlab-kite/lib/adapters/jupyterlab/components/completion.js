import { DataConnector } from '@jupyterlab/statedb';
import { CompletionHandler, KernelConnector } from '@jupyterlab/completer';
import { LabIcon } from '@jupyterlab/ui-components';
import { MarkupContent } from 'vscode-languageserver-types';
import { completionItemKindNames, CompletionTriggerKind } from '../../../lsp';
import { PositionConverter } from '../../../converter';
import kiteLogo from '../../../../style/icons/kite-logo.svg';
export class KiteConnector extends DataConnector {
    /**
     * Create a new Kite connector for completion requests.
     *
     * @param options - The instantiation options for the Kite connector.
     */
    constructor(options) {
        super();
        this.isDisposed = false;
        this.responseType = CompletionHandler.ICompletionItemsResponseType;
        this._trigger_kind = CompletionTriggerKind.Invoked;
        this.suppress_auto_invoke_in = ['comment'];
        this.icon = new LabIcon({
            name: 'jupyterlab-kite:completion-icon',
            svgstr: kiteLogo
        });
        this._editor = options.editor;
        this._connections = options.connections;
        this.virtual_editor = options.virtual_editor;
        this.options = options;
        this.fetchAbort = new AbortController();
        if (options.session) {
            this._kernel_connector = new KernelConnector({
                session: options.session
            });
        }
        this.icon.bindprops({ className: 'kite-logo' });
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        delete this._connections;
        delete this._kernel_connector;
        delete this.virtual_editor;
        delete this.options;
        delete this._editor;
        delete this.icon;
        delete this.isDisposed;
        delete this.fetchAbort;
    }
    abort() {
        this.fetchAbort.abort();
    }
    /**
     * Fetch completion requests.
     *
     * @param request - The completion request text and details.
     */
    fetch(request) {
        return new Promise(async (resolve, reject) => {
            const fetchAbort = new AbortController();
            this.fetchAbort.abort();
            this.fetchAbort = fetchAbort;
            let replacementRange = [-1, -1];
            fetchAbort.signal.addEventListener('abort', () => {
                resolve({
                    start: replacementRange[0],
                    end: replacementRange[1],
                    items: []
                });
            }, { once: true });
            let editor = this._editor;
            const cursor = editor.getCursorPosition();
            const token = editor.getTokenForPosition(cursor);
            if (token.type &&
                this.suppress_auto_invoke_in.indexOf(token.type) !== -1) {
                console.log('[Kite][Completer] Suppressing completer auto-invoke in', token.type);
                return;
            }
            const start = editor.getPositionAt(token.offset);
            const end = editor.getPositionAt(token.offset + token.value.length);
            if (!start || !end) {
                console.log('[Kite][Completer] No start or end position found');
                resolve(KiteConnector.EmptyICompletionItemsReply);
                return;
            }
            let position_in_token = cursor.column - start.column - 1;
            const typed_character = token.value[cursor.column - start.column - 1];
            // Update replacement range based on current editor information
            let prefix = token.value.slice(0, position_in_token + 1);
            // Assume all_non_prefixed = true in this calculation, since if should be if there are no items
            replacementRange = [token.offset + 1, token.offset + prefix.length];
            let start_in_root = this.transform_from_editor_to_root(start);
            let end_in_root = this.transform_from_editor_to_root(end);
            let cursor_in_root = this.transform_from_editor_to_root(cursor);
            let virtual_editor = this.virtual_editor;
            // find document for position
            let document = virtual_editor.document_at_root_position(start_in_root);
            let virtual_start = virtual_editor.root_position_to_virtual_position(start_in_root);
            let virtual_end = virtual_editor.root_position_to_virtual_position(end_in_root);
            let virtual_cursor = virtual_editor.root_position_to_virtual_position(cursor_in_root);
            const kitePromise = async () => {
                try {
                    return await this.fetch_kite(token, typed_character, virtual_start, virtual_end, virtual_cursor, document, position_in_token);
                }
                catch (error) {
                    return {
                        start: replacementRange[0],
                        end: replacementRange[1],
                        items: []
                    };
                }
            };
            const isManual = this._trigger_kind === CompletionTriggerKind.Invoked;
            /**
             * """
             * """
             * has token.type string, so we suppress auto fetching.
             */
            const should_suppress_strings = !isManual && token.type === 'string';
            /**
             * Kernel completions should only be fetched after an alphabetical character or . ' "
             */
            const kernelTriggerRegex = /^[a-zA-Z\.\'\"]+/;
            const kernelPromise = () => {
                /**
                 * Don't fetch kernel completions if:
                 * - No kernel connector
                 * - No request object
                 * - Token type is string (otherwise kernel completions appear within docstrings)
                 * - Preceding character isn't a kernel trigger character (unless request is manual)
                 */
                if (!this._kernel_connector ||
                    !request ||
                    should_suppress_strings ||
                    !(kernelTriggerRegex.test(typed_character) || isManual)) {
                    return KiteConnector.EmptyIReply;
                }
                return this._kernel_connector.fetch(request).catch(() => {
                    return KiteConnector.EmptyIReply;
                });
            };
            const kernelTimeoutPromise = () => {
                const timeout = new Promise(resolve => {
                    setTimeout(resolve, 500, KiteConnector.EmptyIReply);
                });
                return Promise.race([timeout, kernelPromise()]);
            };
            const [kernel, kite] = await Promise.all([
                isManual ? kernelPromise() : kernelTimeoutPromise(),
                kitePromise()
            ]);
            const merged = this.merge_replies(kernel, kite);
            if (fetchAbort.signal.aborted) {
                // will eventually resolve to empty via the registered handler
                return;
            }
            resolve(merged);
        });
    }
    async fetch_kite(token, typed_character, start, end, cursor, document, position_in_token) {
        let connection = this._connections.get(document.id_path);
        if (!connection) {
            console.log('[Kite][Completer] No LSP Connection found');
            return KiteConnector.EmptyICompletionItemsReply;
        }
        const lspCompletionItems = await connection
            .getCompletion(cursor, {
            start,
            end,
            text: token.value
        }, document.document_info, false, typed_character, this.trigger_kind)
            .catch(err => console.error(err));
        console.log('[Kite][Completer] Fetched', lspCompletionItems);
        let prefix = token.value.slice(0, position_in_token + 1);
        let all_non_prefixed = true;
        let items = [];
        let lineText = document
            .get_editor_at_virtual_line(cursor)
            .getLineTokens(cursor.line)
            .map(token => token.string)
            .join('');
        lspCompletionItems.forEach(match => {
            var _a;
            let range = (_a = match.textEdit) === null || _a === void 0 ? void 0 : _a.range;
            let insertion = match.insertText ? match.insertText : match.label;
            if (range) {
                if (range.start.character < start.ch) {
                    // If this completion begins before the given token begins,
                    // we need to trim it so that it begins within the given token instead.
                    let preToken = lineText.substring(range.start.character, start.ch);
                    if (insertion.startsWith(preToken)) {
                        // We can trim this completion because the trimmed portion will match the existing text in the line.
                        insertion = insertion.substring(preToken.length);
                    }
                    else {
                        // We can't trim the beginning of this completion.
                        console.log('[Kite][Completer] Disposing of un-insertable completion: %s', match.insertText ? match.insertText : match.label);
                        return;
                    }
                }
                else if (range.start.character > start.ch + 1) {
                    // The start of the completion can be 1 character past the start of the token,
                    // to accommodate completions after single character tokens like '.' or ' '.
                    // Completions that start further than that fall outside of the standard insertion range.
                    console.log('[Kite][Completer] Disposing of un-insertable completion: %s', match.insertText ? match.insertText : match.label);
                    return;
                }
                if (range.end.character > cursor.ch) {
                    // If the completion goes past the cursor, it is either a type-through completion,
                    // or it modifies characters past the cursor. However, the standard insertion range
                    // only extends past the cursor if all the completions are type-through, so no completions
                    // that modify characters past the cursor are insertable.
                    let postCursor = lineText.substring(cursor.ch, range.end.character);
                    if (insertion.endsWith(postCursor)) {
                        // This will result in the cursor being placed before what the user perceives
                        // as a type-through, instead of after it, which is not ideal.
                        insertion = insertion.substring(0, insertion.length - postCursor.length);
                    }
                    else {
                        // This completion modifies characters past the cursor, so it's un-insertable.
                        console.log('[Kite][Completer] Disposing of un-insertable completion: %s', match.insertText ? match.insertText : match.label);
                        return;
                    }
                }
                else if (range.end.character < cursor.ch) {
                    // The end of the standard completion range will not be before the cursor.
                    // It is either on the cursor, or after it (in a type-through case).
                    // Therefore any completion that ends before the cursor cannot be inserted.
                    console.log('[Kite][Completer] Disposing of un-insertable completion: %s', match.insertText ? match.insertText : match.label);
                    return;
                }
            }
            if (insertion !== match.insertText) {
                console.log('[Kite][Completer] Trimmed %s => %s', match.insertText, insertion);
                match.insertText = insertion;
            }
            let completionItem = {
                label: match.label,
                insertText: match.insertText,
                type: match.hint
                    ? match.hint
                    : match.kind
                        ? completionItemKindNames[match.kind]
                        : '',
                icon: this.icon,
                documentation: MarkupContent.is(match.documentation)
                    ? match.documentation.value
                    : match.documentation,
                filterText: match.filterText,
                noFilter: true
            };
            // Update prefix values
            let text = match.insertText ? match.insertText : match.label;
            if (text.toLowerCase().startsWith(prefix.toLowerCase())) {
                all_non_prefixed = false;
                if (prefix !== token.value) {
                    if (text.toLowerCase().startsWith(token.value.toLowerCase())) {
                        // given a completion insert text "display_table" and two test cases:
                        // disp<tab>data →  display_table<cursor>data
                        // disp<tab>lay  →  display_table<cursor>
                        // we have to adjust the prefix for the latter (otherwise we would get display_table<cursor>lay),
                        // as we are constrained NOT to replace after the prefix (which would be "disp" otherwise)
                        prefix = token.value;
                    }
                }
            }
            items.push(completionItem);
        });
        return {
            // note in the ContextCompleter it was:
            // start: token.offset,
            // end: token.offset + token.value.length,
            // which does not work with "from statistics import <tab>" as the last token ends at "t" of "import",
            // so the completer would append "mean" as "from statistics importmean" (without space!);
            // (in such a case the typedCharacters is undefined as we are out of range)
            // a different workaround would be to prepend the token.value prefix:
            // text = token.value + text;
            // but it did not work for "from statistics <tab>" and lead to "from statisticsimport" (no space)
            start: token.offset + (all_non_prefixed ? 1 : 0),
            end: token.offset + prefix.length,
            items
        };
    }
    merge_replies(kernelReply, kiteReply) {
        const newKernelReply = this.transform(kernelReply);
        if (!newKernelReply.items.length) {
            return kiteReply;
        }
        if (!kiteReply.items.length) {
            return newKernelReply;
        }
        // Dedupe Kite and Kernel items based on label
        const kiteSet = new Set(kiteReply.items.map(item => item.label));
        newKernelReply.items = newKernelReply.items.filter(item => !kiteSet.has(item.label));
        console.log('[Kite]: Merging', kiteReply, newKernelReply);
        if (kiteReply.start === -1) {
            // Use kernel replacement range
            return Object.assign(Object.assign({}, kernelReply), { items: kiteReply.items.concat(newKernelReply.items) });
        }
        else {
            // Use kite replacement range
            return Object.assign(Object.assign({}, kiteReply), { items: kiteReply.items.concat(newKernelReply.items) });
        }
    }
    /**
     * Converts an IReply into an ICompletionItemsReply.
     */
    transform(reply) {
        const items = new Array();
        const metadata = reply.metadata || {};
        const types = metadata._jupyter_types_experimental;
        if (types) {
            types.forEach((item) => {
                const text = item.text;
                const type = item.type;
                items.push({ label: text, type: type === '<unknown>' ? '' : type });
            });
        }
        else {
            const matches = reply.matches;
            matches.forEach(match => {
                items.push({ label: match });
            });
        }
        return { start: reply.start, end: reply.end, items };
    }
    transform_from_editor_to_root(position) {
        let cm_editor = this._editor.editor;
        let cm_start = PositionConverter.ce_to_cm(position);
        return this.virtual_editor.transform_editor_to_root(cm_editor, cm_start);
    }
    get trigger_kind() {
        return this._trigger_kind;
    }
    set trigger_kind(kind) {
        this._trigger_kind = kind;
    }
    with_trigger_kind(kind, fn) {
        try {
            this.trigger_kind = kind;
            return fn();
        }
        finally {
            // Return to the default state
            this.trigger_kind = CompletionTriggerKind.Invoked;
        }
    }
}
/**
 * A namespace for Kite connector statics.
 */
(function (KiteConnector) {
    KiteConnector.EmptyICompletionItemsReply = {
        start: -1,
        end: -1,
        items: []
    };
    KiteConnector.EmptyIReply = {
        start: -1,
        end: -1,
        matches: [],
        metadata: {}
    };
})(KiteConnector || (KiteConnector = {}));
//# sourceMappingURL=completion.js.map