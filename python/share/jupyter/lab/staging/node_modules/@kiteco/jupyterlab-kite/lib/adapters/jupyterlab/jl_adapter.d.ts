import { JupyterFrontEnd } from '@jupyterlab/application';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { CompletionHandler, ICompletionManager } from '@jupyterlab/completer';
import { DocumentRegistry, IDocumentWidget } from '@jupyterlab/docregistry';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { IStateDB } from '@jupyterlab/statedb';
import { CodeJumper } from '@krassowski/jupyterlab_go_to_definition/lib/jumpers/jumper';
import { Signal } from '@lumino/signaling';
import * as CodeMirror from 'codemirror';
import * as lsProtocol from 'vscode-languageserver-protocol';
import { ICommandContext } from '../../command_manager';
import { LSPConnection } from '../../connection';
import { DocumentConnectionManager, IDocumentConnectionData } from '../../connection_manager';
import { CompletionTriggerKind } from '../../lsp';
import { IEditorPosition, IRootPosition } from '../../positioning';
import { IForeignContext, VirtualDocument } from '../../virtual/document';
import { VirtualEditor } from '../../virtual/editor';
import { CodeMirrorAdapter } from '../codemirror/cm_adapter';
import { ILSPFeature, ILSPFeatureConstructor } from '../codemirror/feature';
import { KiteConnector } from './components/completion';
import { FreeTooltip } from './components/free_tooltip';
export declare const lsp_features: Array<ILSPFeatureConstructor>;
export interface IJupyterLabComponentsManager {
    invoke_completer: (kind: CompletionTriggerKind) => void;
    cancel_completer: () => void;
    create_tooltip: (markup: lsProtocol.MarkupContent, cm_editor: CodeMirror.Editor, position: IEditorPosition) => FreeTooltip;
    remove_tooltip: () => void;
    jumper: CodeJumper;
    dispose(): void;
    isDisposed: boolean;
}
export declare class StatusMessage {
    /**
     * The text message to be shown on the statusbar
     */
    message: string;
    changed: Signal<StatusMessage, string>;
    constructor();
    /**
     * Set the text message and (optionally) the timeout to remove it.
     * @param message
     * @param timeout - number of ms to until the message is cleaned;
     *        -1 if the message should stay up indefinitely
     */
    set(message: string, timeout?: number): void;
    cleanup: () => void;
}
/**
 * Foreign code: low level adapter is not aware of the presence of foreign languages;
 * it operates on the virtual document and must not attempt to infer the language dependencies
 * as this would make the logic of inspections caching impossible to maintain, thus the WidgetAdapter
 * has to handle that, keeping multiple connections and multiple virtual documents.
 */
export declare abstract class JupyterLabWidgetAdapter implements IJupyterLabComponentsManager {
    protected app: JupyterFrontEnd;
    protected widget: IDocumentWidget;
    protected rendermime_registry: IRenderMimeRegistry;
    jumper: CodeJumper;
    state: IStateDB;
    protected adapters: Map<VirtualDocument.id_path, CodeMirrorAdapter>;
    private readonly invoke_command;
    protected document_connected: Signal<JupyterLabWidgetAdapter, IDocumentConnectionData>;
    protected abstract current_completion_connector: KiteConnector;
    private _tooltip;
    connection_manager: DocumentConnectionManager;
    status_message: StatusMessage;
    isDisposed: boolean;
    completion_handler?: CompletionHandler;
    protected constructor(app: JupyterFrontEnd, widget: IDocumentWidget, rendermime_registry: IRenderMimeRegistry, invoke: string, connection_manager: DocumentConnectionManager, state: IStateDB);
    on_connection_closed(manager: DocumentConnectionManager, { virtual_document }: IDocumentConnectionData): void;
    dispose(): void;
    abstract virtual_editor: VirtualEditor;
    abstract get document_path(): string;
    abstract get mime_type(): string;
    protected abstract connect_completion(): void;
    get widget_id(): string;
    get language(): string;
    abstract get language_file_extension(): string;
    protected reload_connection(): void;
    protected on_save_state(context: any, state: DocumentRegistry.SaveState): void;
    abstract find_ce_editor(cm_editor: CodeMirror.Editor): CodeEditor.IEditor;
    cancel_completer(): void;
    invoke_completer(kind: CompletionTriggerKind): Promise<void>;
    protected on_connected(data: IDocumentConnectionData): Promise<void>;
    /**
     * Opens a connection for the document. The connection may or may
     * not be initialized, yet, and depending on when this is called, the client
     * may not be fully connected.
     *
     * @param virtual_document a VirtualDocument
     * @param send_open whether to open the document immediately
     */
    protected connect_document(virtual_document: VirtualDocument, send_open?: boolean): Promise<void>;
    /**
     * Handler for opening a document contained in a parent document. The assumption
     * is that the editor already exists for this, and as such the document
     * should be queued for immediate opening.
     *
     * @param host the VirtualDocument that contains the VirtualDocument in another language
     * @param context information about the foreign VirtualDocument
     */
    protected on_foreign_document_opened(host: VirtualDocument, context: IForeignContext): Promise<void>;
    on_foreign_document_closed(host: VirtualDocument, context: IForeignContext): void;
    document_changed(virtual_document: VirtualDocument, document: VirtualDocument, is_init?: boolean): void;
    private connect_adapter;
    private disconnect_adapter;
    get_features(virtual_document: VirtualDocument): Map<string, ILSPFeature>;
    private connect;
    /**
     * Connect the change signal in order to update all virtual documents after a change.
     *
     * Update to the state of a notebook may be done without a notice on the CodeMirror level,
     * e.g. when a cell is deleted. Therefore a JupyterLab-specific signals are watched instead.
     *
     * While by not using the change event of CodeMirror editors we loose an easy way to send selective,
     * (range) updates this can be still implemented by comparison of before/after states of the
     * virtual documents, which is even more resilient and -obviously - editor-independent.
     */
    connect_contentChanged_signal(): void;
    create_adapter(virtual_document: VirtualDocument, connection: LSPConnection): CodeMirrorAdapter;
    update_documents(_slot: any): void;
    get_position_from_context_menu(): IRootPosition;
    get_context(root_position: IRootPosition): ICommandContext;
    get_context_from_context_menu(): ICommandContext;
    create_tooltip(markup: lsProtocol.MarkupContent, cm_editor: CodeMirror.Editor, position: IEditorPosition): FreeTooltip;
    remove_tooltip(): void;
    registerKiteModules(handler: ICompletionManager.ICompletableAttributes, editor: CodeEditor.IEditor, state: IStateDB): void;
}
