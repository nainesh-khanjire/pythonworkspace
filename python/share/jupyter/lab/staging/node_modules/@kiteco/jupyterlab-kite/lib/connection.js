import * as path from 'path';
import { LspWsConnection } from 'lsp-ws-connection';
import { until_ready } from './utils';
export class LSPConnection extends LspWsConnection {
    constructor(options) {
        super(options);
        this.closing_manually = false;
        this.documentsToOpen = [];
        this.status_model = options.kite_status_model;
    }
    sendOpenWhenReady(documentInfo) {
        if (this.isReady) {
            this._sendOpen(documentInfo);
        }
        else {
            this.documentsToOpen.push(documentInfo);
        }
    }
    onServerInitialized(params) {
        super.onServerInitialized(params);
        while (this.documentsToOpen.length) {
            const document = this.documentsToOpen.pop();
            if (document) {
                this._sendOpen(document);
            }
        }
    }
    async track(to, event, props) {
        try {
            await this.connection.sendRequest('kite/track', {
                to,
                event,
                props
            });
        }
        catch (_a) {
            console.warn(`Could not track ${event}, ${props} to ${to}`);
        }
    }
    async fetchKiteOnboarding() {
        let filepath;
        try {
            filepath = await this.connection.sendRequest('kite/onboarding');
            return path.basename(filepath);
        }
        catch (_a) {
            console.warn('Could not get Kite Onboarding file.');
        }
        return '';
    }
    async fetchKiteStatus(documentInfo) {
        let result;
        try {
            result = await this.connection.sendRequest('kite/status', {
                uri: documentInfo.uri
            });
            if (this.status_model) {
                this.status_model.status = result;
            }
        }
        catch (_a) {
            console.warn('Kite Status could not be fetched. Setting to not ready.');
            if (this.status_model) {
                this.status_model.status = null;
            }
        }
    }
    sendSelection(location, documentInfo, text) {
        try {
            this.connection.sendNotification('kite/selection', {
                positions: [{ line: location.line, character: location.ch }],
                textDocument: { uri: documentInfo.uri },
                text
            });
        }
        catch (e) {
            console.warn('[Kite] Selection Notification Error:', e);
        }
        this.fetchKiteStatus(documentInfo);
    }
    sendSelectiveChange(changeEvent, documentInfo) {
        this._sendChange([changeEvent], documentInfo);
    }
    sendFullTextChange(text, documentInfo) {
        this._sendChange([{ text }], documentInfo);
    }
    isRenameSupported() {
        return !!(this.serverCapabilities && this.serverCapabilities.renameProvider);
    }
    async rename(location, documentInfo, newName, emit = true) {
        if (!this.isReady || !this.isRenameSupported()) {
            return;
        }
        const params = {
            textDocument: {
                uri: documentInfo.uri
            },
            position: {
                line: location.line,
                character: location.ch
            },
            newName
        };
        const edit = await this.connection.sendRequest('textDocument/rename', params);
        if (emit) {
            this.emit('renamed', edit);
        }
        return edit;
    }
    initializeParams() {
        const params = super.initializeParams();
        params.initializationOptions = { kiteTypesEnabled: true };
        return params;
    }
    connect(socket) {
        super.connect(socket);
        until_ready(() => {
            return this.isConnected;
        }, -1)
            .then(() => {
            this.connection.onClose(() => {
                this.isConnected = false;
                this.emit('close', this.closing_manually);
            });
        })
            .catch(() => {
            console.error('Could not connect onClose signal');
        });
        return this;
    }
    close() {
        try {
            this.closing_manually = true;
            super.close();
        }
        catch (e) {
            this.closing_manually = false;
        }
    }
    _sendOpen(documentInfo) {
        this.sendOpen(documentInfo);
        this.fetchKiteStatus(documentInfo);
    }
    _sendChange(changeEvents, documentInfo) {
        if (!this.isConnected || !this.isInitialized) {
            return;
        }
        const textDocumentChange = {
            textDocument: {
                uri: documentInfo.uri,
                version: documentInfo.version
            },
            contentChanges: changeEvents
        };
        this.connection.sendNotification('textDocument/didChange', textDocumentChange);
        documentInfo.version++;
        this.fetchKiteStatus(documentInfo);
    }
}
//# sourceMappingURL=connection.js.map