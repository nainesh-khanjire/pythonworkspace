import { VirtualDocument, IForeignContext } from './virtual/document';
import { LSPConnection } from './connection';
import { Signal } from '@lumino/signaling';
import { ILanguageServerManager } from './tokens';
import { KiteStatusModel } from './adapters/jupyterlab/components/status_model';
export interface IDocumentConnectionData {
    virtual_document: VirtualDocument;
    connection: LSPConnection;
}
export interface ISocketConnectionOptions {
    virtual_document: VirtualDocument;
    /**
     * The language identifier, corresponding to the API endpoint on the LSP proxy server.
     */
    language: string;
    /**
     * Path to the document in the JupyterLab space
     */
    document_path: string;
}
/**
 * Each Widget with a document (whether file or a notebook) has its own DocumentConnectionManager
 * (see JupyterLabWidgetAdapter), keeping the virtual document spaces separate if a file is opened twice.
 */
export declare class DocumentConnectionManager {
    connections: Map<VirtualDocument.id_path, LSPConnection>;
    documents: Map<VirtualDocument.id_path, VirtualDocument>;
    initialized: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    connected: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    /**
     * Connection was closed permanently and no-reconnection will be attempted, e.g.:
     *  - there was a serious server error
     *  - user closed the connection,
     *  - re-connection attempts exceeded,
     */
    closed: Signal<DocumentConnectionManager, IDocumentConnectionData>;
    documents_changed: Signal<DocumentConnectionManager, Map<VirtualDocument.id_path, VirtualDocument>>;
    language_server_manager: ILanguageServerManager;
    kite_status_model?: KiteStatusModel;
    private ignored_languages;
    constructor(options: DocumentConnectionManager.IOptions);
    connect_document_signals(virtual_document: VirtualDocument): void;
    disconnect_document_signals(virtual_document: VirtualDocument, emit?: boolean): void;
    on_foreign_document_opened(_host: VirtualDocument, context: IForeignContext): void;
    on_foreign_document_closed(_host: VirtualDocument, context: IForeignContext): void;
    private connect_socket;
    /**
     * Fired the first time a connection is opened. These _should_ be the only
     * invocation of `.on` (once remaining LSPFeature.connection_handlers are made
     * singletons).
     */
    on_new_connection: (connection: LSPConnection) => void;
    private forEachDocumentOfConnection;
    /**
     * TODO: presently no longer referenced. A failing connection would close
     * the socket, triggering the language server on the other end to exit
     */
    retry_to_connect(options: ISocketConnectionOptions, reconnect_delay: number, retrials_left?: number): Promise<void>;
    connect(options: ISocketConnectionOptions): Promise<LSPConnection>;
    unregister_document(virtual_document: VirtualDocument): void;
}
export declare namespace DocumentConnectionManager {
    interface IOptions {
        language_server_manager: ILanguageServerManager;
        kite_status_model?: KiteStatusModel;
    }
    function solve_uris(virtual_document: VirtualDocument, language: string): IURIs;
    interface IURIs {
        base: string;
        document: string;
        server: string;
        socket: string;
    }
}
