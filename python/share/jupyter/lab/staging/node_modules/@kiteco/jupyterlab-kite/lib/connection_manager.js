import { Signal } from '@lumino/signaling';
import { PageConfig, URLExt } from '@jupyterlab/coreutils';
import { sleep, until_ready } from './utils';
import { ILanguageServerManager } from './tokens';
/**
 * Each Widget with a document (whether file or a notebook) has its own DocumentConnectionManager
 * (see JupyterLabWidgetAdapter), keeping the virtual document spaces separate if a file is opened twice.
 */
export class DocumentConnectionManager {
    constructor(options) {
        /**
         * Fired the first time a connection is opened. These _should_ be the only
         * invocation of `.on` (once remaining LSPFeature.connection_handlers are made
         * singletons).
         */
        this.on_new_connection = (connection) => {
            connection.on('error', e => {
                console.warn(e);
                // TODO invalid now
                let error = e.length && e.length >= 1 ? e[0] : new Error();
                // TODO: those codes may be specific to my proxy client, need to investigate
                if (error.message.indexOf('code = 1005') !== -1) {
                    console.warn(`LSP: Connection failed for ${connection}`);
                }
                else if (error.message.indexOf('code = 1006') !== -1) {
                    console.warn('LSP: Connection closed by the server ');
                }
                else {
                    console.error('LSP: Connection error:', e);
                }
                this.forEachDocumentOfConnection(connection, virtual_document => {
                    console.warn('LSP: disconnecting ' + virtual_document.id_path);
                    this.closed.emit({ connection, virtual_document });
                    this.ignored_languages.add(virtual_document.language);
                    console.warn(`Cancelling further attempts to connect ${virtual_document.id_path} and other documents for this language (no support from the server)`);
                });
            });
            connection.on('serverInitialized', capabilities => {
                this.forEachDocumentOfConnection(connection, virtual_document => {
                    // TODO: is this still neccessary, e.g. for status bar to update responsively?
                    this.initialized.emit({ connection, virtual_document });
                });
            });
            connection.on('close', closed_manually => {
                if (!closed_manually) {
                    console.warn('LSP: Connection unexpectedly disconnected');
                }
                else {
                    console.warn('LSP: Connection closed');
                    this.forEachDocumentOfConnection(connection, virtual_document => {
                        this.closed.emit({ connection, virtual_document });
                    });
                }
            });
        };
        this.connections = new Map();
        this.documents = new Map();
        this.ignored_languages = new Set();
        this.connected = new Signal(this);
        this.initialized = new Signal(this);
        this.closed = new Signal(this);
        this.documents_changed = new Signal(this);
        this.language_server_manager = options.language_server_manager;
        this.kite_status_model = options.kite_status_model;
        Private.setLanguageServerManager(options.language_server_manager);
    }
    connect_document_signals(virtual_document) {
        virtual_document.foreign_document_opened.connect(this.on_foreign_document_opened, this);
        virtual_document.foreign_document_closed.connect(this.on_foreign_document_closed, this);
        this.documents.set(virtual_document.id_path, virtual_document);
        this.documents_changed.emit(this.documents);
    }
    disconnect_document_signals(virtual_document, emit = true) {
        virtual_document.foreign_document_opened.disconnect(this.on_foreign_document_opened, this);
        virtual_document.foreign_document_closed.disconnect(this.on_foreign_document_closed, this);
        this.documents.delete(virtual_document.id_path);
        for (const foreign of virtual_document.foreign_documents.values()) {
            this.disconnect_document_signals(foreign, false);
        }
        if (emit) {
            this.documents_changed.emit(this.documents);
        }
    }
    on_foreign_document_opened(_host, context) {
        console.log('LSP: ConnectionManager received foreign document: ', context.foreign_document.id_path);
    }
    on_foreign_document_closed(_host, context) {
        const { foreign_document } = context;
        this.disconnect_document_signals(foreign_document);
    }
    async connect_socket(options) {
        console.log('LSP: Connection Socket', options);
        let { virtual_document, language } = options;
        this.connect_document_signals(virtual_document);
        const uris = DocumentConnectionManager.solve_uris(virtual_document, language);
        const language_server_id = this.language_server_manager.getServerId({
            language
        });
        // lazily load 1) the underlying library (1.5mb) and/or 2) a live WebSocket-
        // like connection: either already connected or potentiailly in the process
        // of connecting.
        const connection = await Private.connection(language, language_server_id, uris, this.on_new_connection, this.kite_status_model);
        // if connecting for the first time, all documents subsequent documents will
        // be re-opened and synced
        this.connections.set(virtual_document.id_path, connection);
        return connection;
    }
    forEachDocumentOfConnection(connection, callback) {
        for (const [virtual_document_id_path, a_connection] of this.connections.entries()) {
            if (connection !== a_connection) {
                continue;
            }
            const document = this.documents.get(virtual_document_id_path);
            if (document) {
                callback(document);
            }
        }
    }
    /**
     * TODO: presently no longer referenced. A failing connection would close
     * the socket, triggering the language server on the other end to exit
     */
    async retry_to_connect(options, reconnect_delay, retrials_left = -1) {
        let { virtual_document } = options;
        if (this.ignored_languages.has(virtual_document.language)) {
            return;
        }
        let interval = reconnect_delay * 1000;
        let success = false;
        while (retrials_left !== 0 && !success) {
            await this.connect(options)
                .then(() => {
                success = true;
            })
                .catch(e => {
                console.warn(e);
            });
            console.log('LSP: will attempt to re-connect in ' + interval / 1000 + ' seconds');
            await sleep(interval);
            // gradually increase the time delay, up to 5 sec
            interval = interval < 5 * 1000 ? interval + 500 : interval;
        }
    }
    async connect(options) {
        console.log('LSP: connection requested', options);
        let connection = await this.connect_socket(options);
        let { virtual_document, document_path } = options;
        if (!connection.isReady) {
            try {
                await until_ready(() => connection.isReady, 200, 200);
            }
            catch (_a) {
                console.warn(`LSP: Connect timed out for ${virtual_document.id_path}`);
                return;
            }
        }
        console.log('LSP:', document_path, virtual_document.id_path, 'connected.');
        this.connected.emit({ connection, virtual_document });
        return connection;
    }
    unregister_document(virtual_document) {
        this.connections.delete(virtual_document.id_path);
        this.documents_changed.emit(this.documents);
    }
}
(function (DocumentConnectionManager) {
    function solve_uris(virtual_document, language) {
        const wsBase = PageConfig.getBaseUrl().replace(/^http/, 'ws');
        const rootUri = PageConfig.getOption('rootUri');
        const virtualDocumentsUri = PageConfig.getOption('virtualDocumentsUri');
        const baseUri = virtual_document.has_lsp_supported_file
            ? rootUri
            : virtualDocumentsUri;
        const language_server_id = Private.getLanguageServerManager().getServerId({
            language
        });
        return {
            base: baseUri,
            document: URLExt.join(baseUri, virtual_document.uri),
            server: URLExt.join('ws://jupyter-kite', language),
            socket: URLExt.join(wsBase, ILanguageServerManager.URL_NS, 'ws', language_server_id)
        };
    }
    DocumentConnectionManager.solve_uris = solve_uris;
})(DocumentConnectionManager || (DocumentConnectionManager = {}));
/**
 * Namespace primarily for language-keyed cache of LSPConnections
 */
var Private;
(function (Private) {
    const _connections = new Map();
    let _promise;
    let _language_server_manager;
    function getLanguageServerManager() {
        return _language_server_manager;
    }
    Private.getLanguageServerManager = getLanguageServerManager;
    function setLanguageServerManager(language_server_manager) {
        _language_server_manager = language_server_manager;
    }
    Private.setLanguageServerManager = setLanguageServerManager;
    /**
     * Return (or create and initialize) the WebSocket associated with the language
     */
    async function connection(language, language_server_id, uris, onCreate, kite_status_model) {
        if (_promise == null) {
            // TODO: consider lazy-loading _only_ the modules that _must_ be webpacked
            // with custom shims, e.g. `fs`
            _promise = import(
            /* webpackChunkName: "jupyter-lsp-connection" */ './connection');
        }
        const { LSPConnection } = await _promise;
        let connection = _connections.get(language_server_id);
        if (connection == null) {
            const socket = new WebSocket(uris.socket);
            const connection = new LSPConnection({
                languageId: language,
                serverUri: uris.server,
                rootUri: uris.base,
                kite_status_model: kite_status_model
            });
            // TODO: remove remaining unbounded users of connection.on
            connection.setMaxListeners(999);
            _connections.set(language_server_id, connection);
            connection.connect(socket);
            onCreate(connection);
        }
        connection = _connections.get(language_server_id);
        return connection;
    }
    Private.connection = connection;
})(Private || (Private = {}));
//# sourceMappingURL=connection_manager.js.map