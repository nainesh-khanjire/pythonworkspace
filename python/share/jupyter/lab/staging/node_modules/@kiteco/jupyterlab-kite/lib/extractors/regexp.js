import { position_at_offset } from '../positioning';
export class RegExpForeignCodeExtractor {
    constructor(options) {
        this.language = options.language;
        this.options = options;
        this.global_expression = new RegExp(options.pattern, 'g');
        this.test_expression = new RegExp(options.pattern, 'g');
        this.expression = new RegExp(options.pattern);
        this.standalone = this.options.is_standalone;
        this.file_extension = this.options.file_extension;
    }
    has_foreign_code(code) {
        let result = this.test_expression.test(code);
        this.test_expression.lastIndex = 0;
        return result;
    }
    extract_foreign_code(code) {
        let lines = code.split('\n');
        let extracts = new Array();
        let started_from = this.global_expression.lastIndex;
        let match = this.global_expression.exec(code);
        let host_code_fragment;
        while (match != null) {
            let matched_string = match[0];
            let position_shift = null;
            let foreign_code_fragment = matched_string.replace(this.expression, 
            // @ts-ignore
            this.options.extract_to_foreign);
            let prefix = '';
            if (typeof this.options.extract_arguments !== 'undefined') {
                prefix = matched_string.replace(this.expression, 
                // @ts-ignore
                this.options.extract_arguments);
                position_shift = position_at_offset(prefix.length, prefix.split('\n'));
            }
            // NOTE:
            // match.index + matched_string.length === this.sticky_expression.lastIndex
            let end_index = this.global_expression.lastIndex;
            if (this.options.keep_in_host || this.options.keep_in_host == null) {
                host_code_fragment = code.substring(started_from, end_index);
            }
            else {
                if (started_from === match.index) {
                    host_code_fragment = '';
                }
                else {
                    host_code_fragment = code.substring(started_from, match.index) + '\n';
                }
            }
            // TODO: this could be slightly optimized (start at start) by using the match[n],
            //  where n is the group to be used; while this reduces the flexibility of extract_to_foreign,
            //  it might be better to enforce such strict requirement
            let start_offset = match.index + matched_string.indexOf(foreign_code_fragment);
            let start = position_at_offset(start_offset, lines);
            let end = position_at_offset(start_offset + foreign_code_fragment.length, lines);
            extracts.push({
                host_code: host_code_fragment,
                foreign_code: prefix + foreign_code_fragment,
                range: { start, end },
                virtual_shift: position_shift
            });
            started_from = this.global_expression.lastIndex;
            match = this.global_expression.exec(code);
        }
        if (started_from !== code.length) {
            let final_host_code_fragment = code.substring(started_from, code.length);
            extracts.push({
                host_code: final_host_code_fragment,
                foreign_code: null,
                range: null,
                virtual_shift: null
            });
        }
        return extracts;
    }
}
//# sourceMappingURL=regexp.js.map