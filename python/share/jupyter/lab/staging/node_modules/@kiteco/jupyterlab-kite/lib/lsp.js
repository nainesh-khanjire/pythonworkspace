var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    DiagnosticSeverity.Error = 1;
    DiagnosticSeverity.Warning = 2;
    DiagnosticSeverity.Information = 3;
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
export var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
export var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    DocumentHighlightKind.Text = 1;
    DocumentHighlightKind.Read = 2;
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
export function inverse_namespace(namespace) {
    const records = {};
    for (let key of Object.keys(namespace)) {
        // @ts-ignore
        records[namespace[key]] = key;
    }
    return records;
}
/**
 * Why programmatic solution rather than hard-coding the namespace the other way around?
 * Because the namespaces are copy-paste from the LSP specification, and it will be easier
 * to maintain this way in the future.
 *
 * Why not simply import from lsProtocol?
 * Because this triggers some strange webpack issue as an additional package would need to be included.
 * Interestingly, the same thing happens when using CompletionTriggerKind.Invoked from lsProtocol.
 */
export const diagnosticSeverityNames = inverse_namespace(DiagnosticSeverity);
export const completionItemKindNames = inverse_namespace(CompletionItemKind);
export const documentHighlightKindNames = inverse_namespace(DocumentHighlightKind);
export var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind.Invoked = 1;
    CompletionTriggerKind.TriggerCharacter = 2;
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
//# sourceMappingURL=lsp.js.map