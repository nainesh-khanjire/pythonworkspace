class MagicsMap extends Map {
    constructor(magic_overrides) {
        super(magic_overrides.map(m => [new RegExp(m.pattern), m.replacement]));
    }
    _override_for(code) {
        for (let [key, value] of this) {
            if (code.match(key)) {
                // @ts-ignore
                return code.replace(key, value);
            }
        }
        return null;
    }
}
class ReversibleMagicsMap extends MagicsMap {
    constructor(magic_overrides) {
        super(magic_overrides);
        this.overrides = magic_overrides;
    }
    get reverse() {
        return this.type(this.overrides.map(override => override.reverse));
    }
}
export class CellMagicsMap extends ReversibleMagicsMap {
    type(overrides) {
        return new CellMagicsMap(overrides);
    }
    override_for(cell) {
        return super._override_for(cell);
    }
}
export class LineMagicsMap extends ReversibleMagicsMap {
    type(overrides) {
        return new LineMagicsMap(overrides);
    }
    override_for(line) {
        return super._override_for(line);
    }
    replace_all(raw_lines, map = this) {
        let substituted_lines = new Array();
        let skip_inspect = new Array();
        for (let i = 0; i < raw_lines.length; i++) {
            let line = raw_lines[i];
            let override = map.override_for(line);
            substituted_lines.push(override == null ? line : override);
            skip_inspect.push(override != null);
        }
        return {
            lines: substituted_lines,
            skip_inspect: skip_inspect
        };
    }
    reverse_replace_all(raw_lines) {
        return this.replace_all(raw_lines, this.reverse).lines;
    }
}
//# sourceMappingURL=maps.js.map