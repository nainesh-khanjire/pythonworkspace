import { VirtualDocument } from './document';
import { IOverridesRegistry } from '../magics/overrides';
import { IForeignCodeExtractorsRegistry } from '../extractors/types';
import * as CodeMirror from 'codemirror';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../positioning';
import { EditorLogConsole } from './console';
export declare type CodeMirrorHandler = (instance: any, ...args: any[]) => void;
/**
 * VirtualEditor extends the CodeMirror.Editor interface; its subclasses may either
 * fast-forward any requests to an existing instance of the CodeMirror.Editor
 * (using ES6 Proxy), or implement custom behaviour, allowing for the use of
 * virtual documents representing code in complex entities such as notebooks.
 */
export declare abstract class VirtualEditor implements CodeMirror.Editor {
    protected language: () => string;
    protected file_extension: () => string;
    protected path: () => string;
    protected overrides_registry: IOverridesRegistry;
    protected foreign_code_extractors: IForeignCodeExtractorsRegistry;
    has_lsp_supported_file: boolean;
    virtual_document: VirtualDocument;
    code_extractors: IForeignCodeExtractorsRegistry;
    /**
     * Signal emitted by the editor that triggered the update, providing the root document of the updated documents.
     */
    private documents_updated;
    /**
     * Whether the editor reflects an interface with multiple cells (such as a notebook)
     */
    has_cells: boolean;
    console: EditorLogConsole;
    isDisposed: boolean;
    constructor(language: () => string, file_extension: () => string, path: () => string, overrides_registry: IOverridesRegistry, foreign_code_extractors: IForeignCodeExtractorsRegistry, has_lsp_supported_file: boolean);
    create_virtual_document(): void;
    dispose(): void;
    /**
     * Once all the foreign documents were refreshed, the unused documents (and their connections)
     * should be terminated if their lifetime has expired.
     */
    on_updated(editor: VirtualEditor, root_document: VirtualDocument): void;
    abstract get_editor_index(position: IVirtualPosition): number;
    transform_virtual_to_editor(position: IVirtualPosition): IEditorPosition;
    abstract transform_editor_to_root(cm_editor: CodeMirror.Editor, position: IEditorPosition): IRootPosition;
    abstract get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    /**
     * Virtual documents update guard.
     */
    private is_update_in_progress;
    private can_update;
    private update_lock;
    /**
     * Execute provided callback within an update-locked context, which guarantees that:
     *  - the previous updates must have finished before the callback call, and
     *  - no update will happen when executing the callback
     * @param fn - the callback to execute in update lock
     */
    with_update_lock(fn: Function): Promise<void>;
    /**
     * Update all the virtual documents, emit documents updated with root document if succeeded,
     * and resolve a void promise. The promise does not contain the text value of the root document,
     * as to avoid an easy trap of ignoring the changes in the virtual documents.
     */
    update_documents(): Promise<void>;
    /**
     * Actual implementation of the update action.
     */
    protected abstract perform_documents_update(): void;
    abstract addEventListener(type: string, listener: EventListenerOrEventListenerObject): void;
    document_at_root_position(position: IRootPosition): VirtualDocument;
    root_position_to_virtual_position(position: IRootPosition): IVirtualPosition;
    get_editor_at_root_position(root_position: IRootPosition): CodeMirror.Editor;
    root_position_to_editor(root_position: IRootPosition): IEditorPosition;
    abstract forEveryBlockEditor(callback: (cm_editor: CodeMirror.Editor) => void, monitor_for_new_blocks?: boolean): void;
    private _event_wrappers;
    /**
     * Proxy the event handler binding to the CodeMirror editors,
     * allowing for multiple actual editors per a virtual editor.
     *
     * Only handlers accepting CodeMirror.Editor are supported for simplicity.
     */
    on(eventName: string, handler: CodeMirrorHandler, ...args: any[]): void;
    off(eventName: string, handler: CodeMirrorHandler, ...args: any[]): void;
}
export interface VirtualEditor extends CodeMirror.Editor {
}
