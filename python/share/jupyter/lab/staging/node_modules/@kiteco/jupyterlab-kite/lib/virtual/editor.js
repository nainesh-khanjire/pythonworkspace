import { VirtualDocument } from './document';
import { until_ready } from '../utils';
import { Signal } from '@lumino/signaling';
import { create_console } from './console';
/**
 * VirtualEditor extends the CodeMirror.Editor interface; its subclasses may either
 * fast-forward any requests to an existing instance of the CodeMirror.Editor
 * (using ES6 Proxy), or implement custom behaviour, allowing for the use of
 * virtual documents representing code in complex entities such as notebooks.
 */
export class VirtualEditor {
    constructor(language, file_extension, path, overrides_registry, foreign_code_extractors, has_lsp_supported_file) {
        this.language = language;
        this.file_extension = file_extension;
        this.path = path;
        this.overrides_registry = overrides_registry;
        this.foreign_code_extractors = foreign_code_extractors;
        this.has_lsp_supported_file = has_lsp_supported_file;
        this.isDisposed = false;
        /**
         * Virtual documents update guard.
         */
        this.is_update_in_progress = false;
        this.update_lock = false;
        this._event_wrappers = new Map();
        this.create_virtual_document();
        this.documents_updated = new Signal(this);
        this.documents_updated.connect(this.on_updated, this);
        this.console = create_console('browser');
    }
    create_virtual_document() {
        this.virtual_document = new VirtualDocument(this.language(), this.path(), this.overrides_registry, this.foreign_code_extractors, false, this.file_extension(), this.has_lsp_supported_file);
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.documents_updated.disconnect(this.on_updated, this);
        for (let [[eventName], wrapped_handler] of this._event_wrappers.entries()) {
            this.forEveryBlockEditor(cm_editor => {
                cm_editor.off(eventName, wrapped_handler);
            }, false);
        }
        this._event_wrappers.clear();
        this.virtual_document.dispose();
        // just to be sure
        this.virtual_document = null;
        this.overrides_registry = null;
        this.foreign_code_extractors = null;
        this.code_extractors = null;
        this.isDisposed = true;
    }
    /**
     * Once all the foreign documents were refreshed, the unused documents (and their connections)
     * should be terminated if their lifetime has expired.
     */
    on_updated(editor, root_document) {
        try {
            root_document.close_expired_documents();
        }
        catch (e) {
            this.console.warn('LSP: Failed to close expired documents');
        }
    }
    transform_virtual_to_editor(position) {
        return this.virtual_document.transform_virtual_to_editor(position);
    }
    can_update() {
        return !this.isDisposed && !this.is_update_in_progress && !this.update_lock;
    }
    /**
     * Execute provided callback within an update-locked context, which guarantees that:
     *  - the previous updates must have finished before the callback call, and
     *  - no update will happen when executing the callback
     * @param fn - the callback to execute in update lock
     */
    async with_update_lock(fn) {
        // this.console.log('Will enter update lock with', fn);
        await until_ready(() => this.can_update(), 12, 10).then(() => {
            try {
                this.update_lock = true;
                fn();
            }
            finally {
                this.update_lock = false;
            }
        });
    }
    /**
     * Update all the virtual documents, emit documents updated with root document if succeeded,
     * and resolve a void promise. The promise does not contain the text value of the root document,
     * as to avoid an easy trap of ignoring the changes in the virtual documents.
     */
    async update_documents() {
        return new Promise(async (resolve, reject) => {
            // defer the update by up to 50 ms (10 retrials * 5 ms break),
            // awaiting for the previous update to complete.
            await until_ready(() => this.can_update(), 10, 5).then(() => {
                if (this.isDisposed || !this.virtual_document) {
                    resolve();
                }
                try {
                    this.is_update_in_progress = true;
                    this.perform_documents_update();
                    if (this.virtual_document) {
                        this.documents_updated.emit(this.virtual_document);
                        this.virtual_document.maybe_emit_changed();
                    }
                    resolve();
                }
                catch (e) {
                    this.console.warn('Documents update failed:', e);
                    reject(e);
                }
                finally {
                    this.is_update_in_progress = false;
                }
            });
        });
    }
    // TODO .root is not really needed as we are in editor now...
    document_at_root_position(position) {
        let root_as_source = position;
        return this.virtual_document.root.document_at_source_position(root_as_source);
    }
    root_position_to_virtual_position(position) {
        let root_as_source = position;
        return this.virtual_document.root.virtual_position_at_document(root_as_source);
    }
    get_editor_at_root_position(root_position) {
        return this.virtual_document.root.get_editor_at_source_line(root_position);
    }
    root_position_to_editor(root_position) {
        return this.virtual_document.root.transform_source_to_editor(root_position);
    }
    /**
     * Proxy the event handler binding to the CodeMirror editors,
     * allowing for multiple actual editors per a virtual editor.
     *
     * Only handlers accepting CodeMirror.Editor are supported for simplicity.
     */
    on(eventName, handler, ...args) {
        let wrapped_handler = (instance, ...args) => {
            try {
                return handler(this, ...args);
            }
            catch (error) {
                this.console.warn('Wrapped handler (which should accept a CodeMirror Editor instance) failed', { error, instance, args, this: this });
            }
        };
        this._event_wrappers.set([eventName, handler], wrapped_handler);
        this.forEveryBlockEditor(cm_editor => {
            cm_editor.on(eventName, wrapped_handler);
        });
    }
    off(eventName, handler, ...args) {
        let wrapped_handler = this._event_wrappers.get([eventName, handler]);
        this.forEveryBlockEditor(cm_editor => {
            cm_editor.off(eventName, wrapped_handler);
        });
    }
}
//# sourceMappingURL=editor.js.map