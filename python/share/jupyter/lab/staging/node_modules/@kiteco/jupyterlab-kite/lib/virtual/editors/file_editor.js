import { VirtualEditor } from '../editor';
export class VirtualFileEditor extends VirtualEditor {
    constructor(language, file_extension, path, cm_editor) {
        // TODO: for now the magics and extractors are not used in FileEditor,
        //  although it would make sense to pass extractors (e.g. for CSS in HTML,
        //  or SQL in Python files) in the future.
        super(language, file_extension, path, {}, {}, true);
        this.has_cells = false;
        this.cm_editor = cm_editor;
        let handler = {
            get: function (target, prop, receiver) {
                if (prop in cm_editor && !(prop in target)) {
                    return cm_editor[prop];
                }
                else {
                    return Reflect.get(target, prop, receiver);
                }
            }
        };
        return new Proxy(this, handler);
    }
    transform_virtual_to_editor(position) {
        return position;
    }
    transform_editor_to_root(cm_editor, position) {
        return position;
    }
    get_editor_index(position) {
        return 0;
    }
    get_cm_editor(position) {
        return this.cm_editor;
    }
    perform_documents_update() {
        if (this.isDisposed) {
            return;
        }
        // it is sufficient to update the root document, all nested documents will follow (be re-generated)
        this.virtual_document.clear();
        this.virtual_document.append_code_block(this.cm_editor.getValue(), this.cm_editor);
    }
    addEventListener(type, listener) {
        this.cm_editor.getWrapperElement().addEventListener(type, listener);
    }
    forEveryBlockEditor(callback) {
        callback(this.cm_editor);
    }
}
//# sourceMappingURL=file_editor.js.map