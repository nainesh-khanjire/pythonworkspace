import { Notebook } from '@jupyterlab/notebook';
import { Cell } from '@jupyterlab/cells';
import { IOverridesRegistry } from '../../magics/overrides';
import { IForeignCodeExtractorsRegistry } from '../../extractors/types';
import { VirtualEditor } from '../editor';
import * as CodeMirror from 'codemirror';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../../positioning';
export declare class VirtualEditorForNotebook extends VirtualEditor {
    notebook: Notebook;
    private wrapper;
    cell_to_corresponding_source_line: Map<Cell, number>;
    cm_editor_to_cell: Map<CodeMirror.Editor, Cell>;
    has_cells: boolean;
    private _proxy;
    constructor(notebook: Notebook, wrapper: HTMLElement, language: () => string, file_extension: () => string, overrides_registry: IOverridesRegistry, foreign_code_extractors: IForeignCodeExtractorsRegistry, path: () => string);
    dispose(): void;
    transform_from_notebook_to_root(cell: Cell, position: IEditorPosition): IRootPosition;
    transform_editor_to_root(cm_editor: CodeMirror.Editor, position: IEditorPosition): IRootPosition;
    transform_from_root_to_editor(pos: IRootPosition): CodeMirror.Position;
    get_editor_index(position: IVirtualPosition): number;
    get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    state: any;
    addKeyMap(map: string | CodeMirror.KeyMap, bottom?: boolean): void;
    addLineClass(line: any, where: string, _class: string): CodeMirror.LineHandle;
    addLineWidget(line: any, node: HTMLElement, options?: CodeMirror.LineWidgetOptions): CodeMirror.LineWidget;
    addOverlay(mode: any, options?: any): void;
    addPanel(node: HTMLElement, options?: CodeMirror.ShowPanelOptions): CodeMirror.Panel;
    charCoords(pos: IRootPosition, mode?: 'window' | 'page' | 'local'): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    coordsChar(object: {
        left: number;
        top: number;
    }, mode?: 'window' | 'page' | 'local'): IRootPosition;
    cursorCoords(where?: boolean, mode?: 'window' | 'page' | 'local'): {
        left: number;
        top: number;
        bottom: number;
    };
    cursorCoords(where?: IRootPosition | null, mode?: 'window' | 'page' | 'local'): {
        left: number;
        top: number;
        bottom: number;
    };
    get any_editor(): CodeMirror.Editor;
    defaultCharWidth(): number;
    defaultTextHeight(): number;
    endOperation(): void;
    execCommand(name: string): void;
    getDoc(): CodeMirror.Doc;
    get_editor_at_root_line(pos: IRootPosition): CodeMirror.Editor;
    getTokenAt(pos: IRootPosition, precise?: boolean): CodeMirror.Token;
    getTokenTypeAt(pos: IRootPosition): string;
    get_cell_at(pos: IVirtualPosition): Cell;
    get_editor_at_virtual_line(pos: IVirtualPosition): CodeMirror.Editor;
    protected perform_documents_update(): void;
    getWrapperElement(): HTMLElement;
    heightAtLine(line: any, mode?: 'window' | 'page' | 'local', includeWidgets?: boolean): number;
    isReadOnly(): boolean;
    lineAtHeight(height: number, mode?: 'window' | 'page' | 'local'): number;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject): void;
    forEveryBlockEditor(callback: (cm_editor: CodeMirror.Editor) => any, monitor_for_new_blocks?: boolean): void;
    /**
     * Find a cell in notebook which uses given CodeMirror editor.
     * This function is O(n) - when looking up many cells
     * using a hashmap based approach may be more efficient.
     * @param cm_editor
     */
    find_cell_by_editor(cm_editor: CodeMirror.Editor): {
        cell_id: number;
        cell: Cell;
    };
}
