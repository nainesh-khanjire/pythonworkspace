import { VirtualEditor } from '../editor';
// @ts-ignore
class DocDispatcher {
    constructor(virtual_notebook) {
        this.virtual_editor = virtual_notebook;
    }
    markText(from, to, options) {
        // TODO: edgecase: from and to in different cells
        let editor = this.virtual_editor.virtual_document.get_editor_at_source_line(from);
        let notebook_map = this.virtual_editor;
        return editor
            .getDoc()
            .markText(notebook_map.transform_from_root_to_editor(from), notebook_map.transform_from_root_to_editor(to), options);
    }
    getCursor(start) {
        let cell = this.virtual_editor.notebook.activeCell;
        if (cell == null) {
            return;
        }
        let active_editor = cell.editor;
        let cursor = active_editor.editor
            .getDoc()
            .getCursor(start);
        return this.virtual_editor.transform_from_notebook_to_root(cell, cursor);
    }
}
export class VirtualEditorForNotebook extends VirtualEditor {
    constructor(notebook, wrapper, language, file_extension, overrides_registry, foreign_code_extractors, path) {
        super(language, file_extension, () => path() + '.' + file_extension(), overrides_registry, foreign_code_extractors, false);
        this.notebook = notebook;
        this.wrapper = wrapper;
        this.has_cells = true;
        this.cell_to_corresponding_source_line = new Map();
        this.cm_editor_to_cell = new Map();
        this.overrides_registry = overrides_registry;
        this.code_extractors = foreign_code_extractors;
        this.language = language;
        this._proxy = new Proxy(this, {
            get: function (target, prop, receiver) {
                if (!(prop in target)) {
                    console.warn(`Unimplemented method ${prop} for VirtualEditorForNotebook`);
                    return;
                }
                else {
                    return Reflect.get(target, prop, receiver);
                }
            }
        });
        return this._proxy;
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.cm_editor_to_cell.clear();
        this.cell_to_corresponding_source_line.clear();
        super.dispose();
        // just to be sure
        this.forEveryBlockEditor = null;
        this._proxy = null;
    }
    transform_from_notebook_to_root(cell, position) {
        // TODO: if cell is not known, refresh
        let shift = this.cell_to_corresponding_source_line.get(cell);
        if (shift === undefined) {
            throw Error('Cell not found in cell_line_map');
        }
        return Object.assign(Object.assign({}, position), { line: position.line + shift });
    }
    transform_editor_to_root(cm_editor, position) {
        let cell = this.cm_editor_to_cell.get(cm_editor);
        return this.transform_from_notebook_to_root(cell, position);
    }
    transform_from_root_to_editor(pos) {
        // from notebook to editor space
        return this.virtual_document.transform_source_to_editor(pos);
    }
    get_editor_index(position) {
        let cell = this.get_cell_at(position);
        return this.notebook.widgets.findIndex(other_cell => {
            return cell === other_cell;
        });
    }
    get_cm_editor(position) {
        return this.get_editor_at_root_line(position);
    }
    addKeyMap(map, bottom) {
        return;
    }
    addLineClass(line, where, _class) {
        return undefined;
    }
    addLineWidget(line, node, options) {
        return undefined;
    }
    addOverlay(mode, options) {
        for (let cell of this.notebook.widgets) {
            // TODO: use some more intelligent strategy to determine editors to test
            let cm_editor = cell.editor;
            cm_editor.editor.addOverlay(mode, options);
        }
    }
    addPanel(node, 
    // @ts-ignore
    options
    // @ts-ignore
    ) {
        return undefined;
    }
    charCoords(pos, mode) {
        try {
            let editor = this.get_editor_at_root_line(pos);
            return editor.charCoords(pos, mode);
        }
        catch (e) {
            console.log(e);
            return { bottom: 0, left: 0, right: 0, top: 0 };
        }
    }
    coordsChar(object, mode) {
        for (let cell of this.notebook.widgets) {
            // TODO: use some more intelligent strategy to determine editors to test
            let cm_editor = cell.editor;
            let pos = cm_editor.editor.coordsChar(object, mode);
            if (pos.outside === 1) {
                continue;
            }
            return this.transform_from_notebook_to_root(cell, pos);
        }
    }
    cursorCoords(where, mode) {
        if (typeof where !== 'boolean') {
            let editor = this.get_editor_at_root_line(where);
            return editor.cursorCoords(this.transform_from_root_to_editor(where));
        }
        return { bottom: 0, left: 0, top: 0 };
    }
    get any_editor() {
        return this.notebook.widgets[0].editor.editor;
    }
    defaultCharWidth() {
        return this.any_editor.defaultCharWidth();
    }
    defaultTextHeight() {
        return this.any_editor.defaultTextHeight();
    }
    endOperation() {
        for (let cell of this.notebook.widgets) {
            let cm_editor = cell.editor;
            cm_editor.editor.endOperation();
        }
    }
    execCommand(name) {
        for (let cell of this.notebook.widgets) {
            let cm_editor = cell.editor;
            cm_editor.editor.execCommand(name);
        }
    }
    getDoc() {
        let dummy_doc = new DocDispatcher(this);
        // @ts-ignore
        return dummy_doc;
    }
    get_editor_at_root_line(pos) {
        return this.virtual_document.root.get_editor_at_source_line(pos);
    }
    getTokenAt(pos, precise) {
        if (pos === undefined) {
            return;
        }
        let editor = this.get_editor_at_root_line(pos);
        return editor.getTokenAt(this.transform_from_root_to_editor(pos));
    }
    getTokenTypeAt(pos) {
        let editor = this.virtual_document.get_editor_at_source_line(pos);
        return editor.getTokenTypeAt(this.transform_from_root_to_editor(pos));
    }
    // TODO: make a mapper class, with mapping function only
    get_cell_at(pos) {
        let cm_editor = this.get_editor_at_virtual_line(pos);
        return this.cm_editor_to_cell.get(cm_editor);
    }
    get_editor_at_virtual_line(pos) {
        return this.virtual_document.get_editor_at_virtual_line(pos);
    }
    perform_documents_update() {
        if (this.isDisposed) {
            return;
        }
        this.virtual_document.clear();
        this.cell_to_corresponding_source_line.clear();
        this.cm_editor_to_cell.clear();
        if (this.notebook.isDisposed) {
            return;
        }
        this.notebook.widgets.every(cell => {
            let codemirror_editor = cell.editor;
            let cm_editor = codemirror_editor.editor;
            this.cm_editor_to_cell.set(cm_editor, cell);
            if (cell.model.type === 'code') {
                let cell_code = cm_editor.getValue();
                // every code cell is placed into the cell-map
                this.cell_to_corresponding_source_line.set(cell, this.virtual_document.last_source_line);
                this.virtual_document.append_code_block(cell_code, cm_editor);
            }
            return true;
        });
    }
    getWrapperElement() {
        return this.wrapper;
    }
    heightAtLine(line, mode, includeWidgets) {
        return 0;
    }
    isReadOnly() {
        return false;
    }
    lineAtHeight(height, mode) {
        return 0;
    }
    addEventListener(type, listener) {
        this.forEveryBlockEditor(cm_editor => {
            cm_editor.getWrapperElement().addEventListener(type, listener);
        });
    }
    forEveryBlockEditor(callback, monitor_for_new_blocks = true) {
        const cells_with_handlers = new Set();
        for (let cell of this.notebook.widgets) {
            let cm_editor = cell.editor.editor;
            if (cell.model.type === 'code') {
                cells_with_handlers.add(cell);
                callback(cm_editor);
            }
        }
        if (monitor_for_new_blocks) {
            this.notebook.activeCellChanged.connect((notebook, cell) => {
                if (cell == null) {
                    return;
                }
                let cm_editor = cell.editor.editor;
                if (!cells_with_handlers.has(cell) && cell.model.type === 'code') {
                    callback(cm_editor);
                }
            });
        }
    }
    /**
     * Find a cell in notebook which uses given CodeMirror editor.
     * This function is O(n) - when looking up many cells
     * using a hashmap based approach may be more efficient.
     * @param cm_editor
     */
    find_cell_by_editor(cm_editor) {
        let cells = this.notebook.widgets;
        for (let i = 0; i < cells.length; i++) {
            let cell = cells[i];
            let cell_editor = cell.editor.editor;
            if (cell_editor === cm_editor) {
                return {
                    cell_id: i,
                    cell: cell
                };
            }
        }
    }
}
//# sourceMappingURL=notebook.js.map