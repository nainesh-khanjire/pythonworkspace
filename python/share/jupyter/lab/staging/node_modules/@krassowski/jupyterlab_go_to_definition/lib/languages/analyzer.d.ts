import { CodeEditor } from '@jupyterlab/codeeditor';
import { ITokensProvider } from '../editors/editor';
export declare type RuleFunction = (context: TokenContext) => boolean;
export declare type QueryFunction = (context: TokenContext) => string[];
export declare class TokenContext implements CodeEditor.IToken {
    tokens: Array<CodeEditor.IToken>;
    _previous: TokenContext;
    token: CodeEditor.IToken;
    _next: TokenContext;
    index: number;
    constructor(token: CodeEditor.IToken, tokens: Array<CodeEditor.IToken>, index: number);
    get simple_next(): string;
    get simple_previous(): string;
    get previous(): TokenContext;
    get next(): TokenContext;
    get value(): string;
    get type(): string;
    get offset(): number;
    get exists(): boolean;
}
export declare abstract class LanguageAnalyzer {
    tokens: Array<CodeEditor.IToken>;
    tokensProvider: ITokensProvider;
    supportsKernel: boolean;
    /**
     * Name of a variable for which a definition is sought
     */
    constructor(tokensProvider: ITokensProvider);
    abstract definitionRules: Array<RuleFunction>;
    isCrossFileReference(context: TokenContext): boolean;
    guessReferencePath(context: TokenContext): string[];
    referencePathQuery(context: TokenContext): string;
    definitionLocationQuery(context: TokenContext): string;
    _maybe_setup_tokens(): void;
    _get_token_index(token: CodeEditor.IToken): number;
    isDefinition(token: CodeEditor.IToken, i: number): boolean;
    nameMatches(name: string, token: CodeEditor.IToken): boolean;
    getDefinitions(variable: string): CodeEditor.IToken[];
    isAssignment(token: CodeEditor.IToken): boolean;
    /**
     * Check whether testedToken belongs to same assignment expression as originToken
     *
     * #### Notes
     * To verify if token belongs to same assignment expression, the tokens
     * between testedToken and originToken as tested. The token is in same
     * assignment expression if there is an assignment token in between and
     * there are no expression-terminating tokens after such an assignment.
     *
     * We only need to look at the first assignment token, see this example:
     * a = 1; b = a
     */
    isTokenInSameAssignmentExpression(testedToken: CodeEditor.IToken, originToken: CodeEditor.IToken): boolean;
    abstract _selectTerminatingTokens(tokens: Array<CodeEditor.IToken>): Array<CodeEditor.IToken>;
}
export declare abstract class LanguageWithOptionalSemicolons extends LanguageAnalyzer {
    _selectTerminatingTokens(tokens: Array<CodeEditor.IToken>): CodeEditor.IToken[];
    traverse_left(previous: TokenContext, step_on: string): TokenContext;
    traverse_right(next: TokenContext, step_on: string): TokenContext;
}
interface ITokenWithIndex {
    index: number;
    token: CodeEditor.IToken;
}
export declare function _closestMeaningfulTokenWithIndex(tokenIndex: number, tokens: Array<CodeEditor.IToken>, direction: number): ITokenWithIndex;
export {};
