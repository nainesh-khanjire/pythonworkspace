import { expect } from 'chai';
import { LanguageWithOptionalSemicolons } from './analyzer';
class TextBasedTokensProvider {
    setTokensFromText(text) {
        this.tokens = text.split(' ').map((value, i) => {
            return { value: value, offset: i };
        });
    }
    getTokens() {
        return this.tokens;
    }
    getTokenAt(offset) {
        return;
    }
}
class TestLanguageAnalyzer extends LanguageWithOptionalSemicolons {
    constructor() {
        super(...arguments);
        this.definitionRules = [];
    }
    isTokenInSameAssignmentExpression(testedToken, originToken) {
        return false;
    }
}
describe('LanguageAnalyzer', () => {
    let analyzer;
    let testToken;
    let tokensProvider;
    beforeEach(() => {
        tokensProvider = new TextBasedTokensProvider();
        analyzer = new TestLanguageAnalyzer(tokensProvider);
    });
    describe('#nameMatches()', () => {
        beforeEach(() => {
            tokensProvider.setTokensFromText('test_token');
            testToken = { value: null, offset: null };
        });
        it('should recognize tokens by name', () => {
            testToken.value = 'test_token';
            let match = analyzer.nameMatches('test_token', testToken);
            expect(match).to.be.true;
        });
        it('should be case-sensitive', () => {
            testToken.value = 'Test_token';
            let match = analyzer.nameMatches('test_token', testToken);
            expect(match).to.be.false;
        });
    });
});
//# sourceMappingURL=analyzer.spec.js.map