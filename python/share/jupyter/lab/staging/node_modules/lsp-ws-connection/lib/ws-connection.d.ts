/// <reference types="node" />
import * as events from 'events';
import * as protocol from 'vscode-languageserver-protocol';
import { MessageConnection } from 'vscode-ws-jsonrpc';
import { ILspConnection, ILspOptions, IPosition, ITokenInfo, IDocumentInfo, AnyLocation } from './types';
/**
 * Changes as compared to upstream:
 *  - markdown is preferred over plaintext
 *  - informative members are public and others are protected, not private
 *  - onServerInitialized() was extracted; it also emits a message once connected
 *  - initializeParams() was extracted, and can be modified by subclasses
 *  - typescript 3.7 was adopted to clean up deep references
 */
export declare class LspWsConnection extends events.EventEmitter implements ILspConnection {
    isConnected: boolean;
    isInitialized: boolean;
    documentInfo: ILspOptions;
    serverCapabilities: protocol.ServerCapabilities;
    protected socket: WebSocket;
    protected connection: MessageConnection;
    private rootUri;
    constructor(options: ILspOptions);
    get isReady(): boolean;
    /**
     * Initialize a connection over a web socket that speaks the LSP protocol
     */
    connect(socket: WebSocket): this;
    close(): void;
    /**
     * Initialization parameters to be sent to the language server.
     * Subclasses can overload this when adding more features.
     */
    protected initializeParams(): protocol.InitializeParams;
    sendInitialize(): void;
    sendOpen(documentInfo: IDocumentInfo): void;
    sendChange(documentInfo: IDocumentInfo): void;
    sendSaved(documentInfo: IDocumentInfo): void;
    getHoverTooltip(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<protocol.Hover>;
    getCompletion(location: IPosition, token: ITokenInfo, documentInfo: IDocumentInfo, emit?: boolean, triggerCharacter?: string, triggerKind?: protocol.CompletionTriggerKind): Promise<protocol.CompletionList | protocol.CompletionItem[]>;
    getDetailedCompletion(completionItem: protocol.CompletionItem): void;
    getSignatureHelp(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<protocol.SignatureHelp>;
    /**
     * Request the locations of all matching document symbols
     */
    getDocumentHighlights(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<protocol.DocumentHighlight[]>;
    /**
     * Request a link to the definition of the current symbol. The results will not be displayed
     * unless they are within the same file URI
     */
    getDefinition(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<AnyLocation>;
    /**
     * Request a link to the type definition of the current symbol. The results will not be displayed
     * unless they are within the same file URI
     */
    getTypeDefinition(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<AnyLocation>;
    /**
     * Request a link to the implementation of the current symbol. The results will not be displayed
     * unless they are within the same file URI
     */
    getImplementation(location: IPosition, documentInfo: IDocumentInfo): void;
    /**
     * Request a link to all references to the current symbol. The results will not be displayed
     * unless they are within the same file URI
     */
    getReferences(location: IPosition, documentInfo: IDocumentInfo, emit?: boolean): Promise<Location[]>;
    /**
     * The characters that trigger completion automatically.
     */
    getLanguageCompletionCharacters(): string[];
    /**
     * The characters that trigger signature help automatically.
     */
    getLanguageSignatureCharacters(): string[];
    /**
     * Does the server support go to definition?
     */
    isDefinitionSupported(): boolean;
    /**
     * Does the server support go to type definition?
     */
    isTypeDefinitionSupported(): boolean;
    /**
     * Does the server support go to implementation?
     */
    isImplementationSupported(): boolean;
    /**
     * Does the server support find all references?
     */
    isReferencesSupported(): boolean;
    protected onServerInitialized(params: protocol.InitializeResult): void;
}
